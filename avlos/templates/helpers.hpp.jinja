/*
* This file was automatically generated using Avlos.
* https://github.com/tinymovr/avlos
*
* Any changes to this file will be overwritten when
* content is regenerated.
*/

#pragma once

#include <cstdint>

#define EP_BITS (6)
#define RECV_DELAY_US (160.0f)

typedef void (*send_callback)(uint32_t arbitration_id, uint8_t *data, uint8_t dlc, bool rtr);
typedef bool (*recv_callback)(uint32_t arbitration_id, uint8_t *data, uint8_t *dlc);

class Node {
    public:

    Node(uint8_t _can_node_id, send_callback _send_cb, recv_callback _recv_cb):
        can_node_id(_can_node_id), send_cb(_send_cb), recv_cb(_recv_cb) {}

    protected:
    uint8_t can_node_id;
    send_callback send_cb;
    recv_callback recv_cb;
    uint8_t _data[8];
    uint8_t _dlc;
    uint8_t get_arbitration_id(uint8_t cmd_id) {
        return this->can_node_id << EP_BITS | cmd_id;
    }
    void send(uint8_t cmd_id, uint8_t *data, uint8_t data_size, bool rtr)
    {
        const uint8_t arb_id = this->get_arbitration_id(cmd_id);
        this->send_cb(arb_id, data, data_size, rtr);
    }

    bool recv(uint8_t cmd_id, uint8_t *data, uint8_t *data_size, uint16_t delay_us)
    {
        // A delay of a few 100s of us needs to be inserted
        // to ensure the response has been transmitted.
        // TODO: Better handle this using an interrupt.
        if (delay_us > 0)
        {
            delayMicroseconds(delay_us);
        }
        const uint8_t arb_id = this->get_arbitration_id(cmd_id);
        return this->recv_cb(arb_id, data, data_size);
    }
}
